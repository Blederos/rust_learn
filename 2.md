# 4.5 - Rust中的打印相关宏

## 一、认识几种打印相关的宏
- **宏是什么？**
    - 以 `!` 结尾的代码，比如 `println!`，它是一种特殊的 Rust 工具，比函数更灵活，能帮你处理格式化的输出。
    - 它们都属于 Rust 标准库，可以直接使用。

- **四种常用打印宏**
    - **`println!`**：打印内容并**自动换行**（ln 就是 line 的缩写）。之前见过的，用来输出 `"Hello, world!"`。
    - **`print!`**：打印内容**但不换行**。适合连续输出多个内容到同一行。
    - **`eprintln!` / `eprint!`**：这两个是专门用来打印**错误信息**的。它们会把内容送到“标准错误”流（stderr），而普通的 `print!` 和 `println!` 送到“标准输出”流（stdout）。
        - 虽然默认情况下，标准输出和标准错误都会显示在屏幕上，但区分它们有好处：比如你可以把普通输出和错误信息分开保存到不同文件里。

- **一个特殊的格式化宏：`format!`**
    - **作用**：它**不打印**任何东西，而是根据你给的格式，生成一个新的字符串。
    - **用途**：当你想把多个变量拼接成一个字符串，并且需要控制格式时（比如保留小数点后两位），就可以用 `format!`。
    - **用法**：里面也用 `{}` 作为占位符，跟 `println!` 一样。生成的结果是一个 `String` 类型的值，可以赋值给变量，之后再用 `println!` 打印出来。

## 二、占位符 `{}` 的简单用法
- 在 `println!`、`print!`、`eprintln!`、`format!` 里，都可以用 `{}` 来表示“这里要插入一个变量的值”。
- 例如：
  ```rust
  let name = "小明";
  println!("你好，{}！", name);
  ```
  输出：`你好，小明！`

## 三、一个综合示例及遇到的问题

### 1. 创建并运行示例项目
- 新建一个项目：`cargo new print_02`
- 编写代码（以文档中的示例为参考）：
  ```rust
  print!("hello ");                // 不带换行打印
  let s1 = String::from("world");
  let s2 = String::from("!");
  eprintln!("error message");       // 打印到标准错误
  let message = format!("{} {}", s1, s2);  // 格式化字符串，不打印
  println!("{}", message);          // 打印拼接后的字符串
  ```

### 2. 预期 vs 实际输出顺序
- **你可能以为**：先输出 `hello `，然后输出错误信息 `error message`，最后输出 `world !`。
- **但实际运行（`cargo run`）可能看到**：错误信息 `error message` 先显示，然后才是 `hello world !`。
- **为什么会这样？** —— 缓冲机制捣的鬼
    - **标准输出（stdout）**：普通打印（`print!`, `println!`）是有**缓冲**的。数据不会立刻送到屏幕，而是攒到一定量（比如遇到换行符或者缓冲区满）才一次性显示。这样可以提高效率。
    - **标准错误（stderr）**：错误打印（`eprint!`, `eprintln!`）是**无缓冲**的，数据会**立即**送到屏幕。
    - 所以 `eprintln!` 的信息不管代码位置在哪，都会抢先显示，而 `print!` 的 `"hello "` 还待在缓冲区里没出来，等到后面 `println!` 遇到换行，才把缓冲区的内容（包括 `"hello "`）一起刷出来。

### 3. 如何让输出顺序与代码一致？
- 可以在需要的地方**手动刷新**标准输出的缓冲区，强制把积攒的内容立刻输出。
- 方法：在 `print!` 后面加上 `std::io::stdout().flush().unwrap();`
    - `std::io::stdout()` 获取标准输出流
    - `.flush()` 方法刷新缓冲区
    - `.unwrap()` 简单处理可能发生的错误（先忽略细节）
- 加上刷新后，`"hello "` 就会在 `eprintln!` 之前显示，顺序就正常了。

## 四、重定向：把输出分开存放
- **重定向符号 `>`**：在命令行执行程序时，可以用 `>` 把标准输出（stdout）的内容**重定向**到一个文件。
    - 例如：`cargo run > output.txt`
    - 结果：所有 `print!` 和 `println!` 的输出都写入 `output.txt` 文件，而 `eprintln!` 的错误信息依然显示在终端。
- **重定向标准错误**：用 `2>` 可以把错误信息单独存到文件。
    - 例如：`cargo run 2> error.txt`
    - 结果：错误信息进入 `error.txt`，普通输出仍在屏幕。
- **同时重定向**：可以用 `> output.txt 2> error.txt` 把两者分开保存。

## 五、`format!` 宏的返回值
- 示例中 `format!("{} {}", s1, s2)` 会返回一个 `String` 类型的字符串，内容是 `"world !"`（注意 `s1` 是 `"world"`，`s2` 是 `"!"`，中间有空格）。
- 这个字符串被保存在变量 `message` 中，然后我们再用 `println!` 把它打印出来。
- **注意**：你不能直接 `println!(message)` 来打印，因为 `println!` 的第一个参数必须是格式字符串，里面可以包含占位符。要打印变量 `message` 的值，应该写成 `println!("{}", message)`。

## 六、总结与下集预告
- 我们学到了：
    - 不同打印宏的区别：有无换行、输出到 stdout 还是 stderr。
    - 占位符 `{}` 的使用。
    - 缓冲机制导致输出顺序问题及解决方法。
    - 重定向把输出分流到文件。
    - `format!` 能生成字符串而不打印。
- **下一讲**：深入 `format!`，学习更多格式化技巧，比如**命名占位符**，让格式化更灵活。